<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Serialization" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="Newtonsoft.Json.dll" #>
<#@ import namespace="Newtonsoft.Json.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Xml.Serialization" #>

<#
	var path = Host.ResolvePath("");
    var swaggerApiProxySettings = Settings.GetSettings(path);
    foreach (var endPoint in swaggerApiProxySettings.EndPoints)
    {
        var httpClient = new HttpClient();
        var result = httpClient.GetStringAsync(endPoint.Url).Result;
		var parser = new SwaggerParser();
        var proxyDefinition = parser.ParseSwaggerDoc(result);
    }
#>

<#+
    static class Settings
    {
        public static SwaggerApiProxySettings GetSettings(string path)
        {
            using (var settingStream = System.IO.File.OpenRead(Path.Combine(path, "SwaggerApiProxy.tt.settings.xml")))
            {
                var serializer = new XmlSerializer(typeof (SwaggerApiProxySettings));
                return (SwaggerApiProxySettings) serializer.Deserialize(settingStream);
            }
        }
    }
	
	/// <remarks/>
	[System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
	[System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
	public partial class SwaggerApiProxySettings
	{
		/// <remarks/>
		[System.Xml.Serialization.XmlArrayItemAttribute("EndPoint", IsNullable = false)]
		public SwaggerApiProxySettingsEndPoint[] EndPoints { get; set; }
	}

	/// <remarks/>
	[System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
	public partial class SwaggerApiProxySettingsEndPoint
	{
		/// <remarks/>
		public string Url { get; set; }

		/// <remarks/>
		public string Namespace { get; set; }

		/// <remarks/>
		public string Suffix { get; set; }

		/// <remarks/>
		public string BaseProxyClass { get; set; }
	}



    public class SwaggerParser
    {
        public ProxyDefinition ParseSwaggerDoc(string document)
        {
            var jObject = JObject.Parse(document);

            var proxyDefinition = new ProxyDefinition();
            ParsePaths(jObject, proxyDefinition);
            ParseDefinitions(jObject, proxyDefinition);

            return proxyDefinition;
        }

        private void ParsePaths(JObject jObject, ProxyDefinition proxyDefinition)
        {
            foreach (var pathToken in jObject["paths"].Cast<JProperty>())
            {
                var path = pathToken.Name;
                foreach (var operationToken in pathToken.First.Cast<JProperty>())
                {
                    var method = operationToken.Name;

                    string returnType;
                    var schema = operationToken.First["responses"]["200"];
                    if (schema != null)
                    {
                        returnType = GetTypeName(schema);
                    }
                    else
                    {
                        returnType = null;
                    }

                    var parameters = new List<Parameter>();
                    var paramTokens = operationToken.First["parameters"];
                    if (paramTokens != null)
                    {
                        foreach (var prop in paramTokens)
                        {
                            var typeName = GetTypeName(prop);
                            var name = prop["name"].ToString();
                            var parameterIn = prop["in"].ToString().Equals("path") ? ParameterIn.Path : ParameterIn.Body;
                            var isRequired = prop["required"].ToObject<bool>();
                            parameters.Add(new Parameter(typeName, name, parameterIn, isRequired));
                        }
                    }

                    proxyDefinition.Operations.Add(new Operation(returnType, method, path, parameters));
                }
            }
        }

		private void ParseDefinitions(JObject jObject, ProxyDefinition proxyDefinition)
        {
            foreach (var definitionToken in jObject["definitions"].Where(i => i.Type == JTokenType.Property).Cast<JProperty>())
            {
                var classDefinition = new ClassDefinition(definitionToken.Name);
                var allOf = definitionToken.First["allOf"];
                if (allOf != null)
                {
                    foreach (var itemToken in allOf)
                    {
                        var refType = itemToken["$ref"] as JValue;
                        if (refType != null)
                        {
                            classDefinition.Inherits = refType.Value.ToString();
                        }

                        var properties = itemToken["properties"];
                        if (properties != null)
                        {
                            foreach (var prop in properties)
                            {
                                var typeName = GetTypeName(prop.First);
                                var name = ((JProperty)prop).Name;
                                classDefinition.Properties.Add(new Property(typeName, name));
                            }
                        }
                    }
                }
                else
                {
                    var properties = definitionToken.Value["properties"];
                    foreach (var prop in properties)
                    {
                        var typeName = GetTypeName(prop.First);
                        var name = ((JProperty)prop).Name;
                        classDefinition.Properties.Add(new Property(typeName, name));
                    }
                }


                proxyDefinition.ClassDefinitions.Add(classDefinition);
            }
        }

        internal string ParseRef(string input)
        {
            return input.StartsWith("#/definitions/") ? input.Substring("#/definitions/".Length) : input;
        }

        internal string GetTypeName(JToken token)
        {
            var refType  =token["$ref"] as JValue;
            if (refType != null)
            {
                return ParseRef(refType.Value.ToString());
            }

            var schema = token["schema"];
            if (schema != null)
            {
                return GetTypeName(schema);
            }

            var type = token["type"] as JValue;
            if (type == null)
                return null;

            if (type.Value.Equals("boolean"))
            {
                return "bool";
            }
            if (type.Value.Equals("string"))
            {
                var format = token["format"] as JValue;
                if (format == null)
                    return "string";

                if (format.Value.Equals("date") || format.Value.Equals("date-time"))
                    return "DateTime";

                if (format.Value.Equals("byte"))
                    return "byte";

                return "string";
            }

            if (type.Value.Equals("integer"))
            {
                var format = token["format"] as JValue;
                if (format != null)
                {
                    if (format.Value.Equals("int32"))
                        return "int";

                    if (format.Value.Equals("int64"))
                        return "long";
                }

                return "int";
            }

            if (type.Value.Equals("number"))
            {
                var format = token["format"] as JValue;
                if (format != null)
                {
                    if (format.Value.Equals("float"))
                        return "float";

                    if (format.Value.Equals("double"))
                        return "long";
                }
            }

            if (type.Value.Equals("array"))
            {
                var jToken = token["items"];
                return string.Format("List<{0}>", GetTypeName(jToken));
            }

            return "";
        }
    }


    public class ClassDefinition
    {
        public ClassDefinition(string name)
        {
            Name = name;
            Properties = new List<Property>();
        }

        public string Name { get; set; }
        public List<Property>  Properties { get; set; }
        public string Inherits { get; set; }
    }

	public class Operation
    {
        public Operation(string returnType, string method, string path, List<Parameter> parameters)
        {
            Path = path;
            Method = method;
            Parameters = parameters;
            ReturnType = returnType;
        }

        public string Path { get; set; }
        public string Method { get; set; }
        public List<Parameter> Parameters { get; set; }
        public string ReturnType { get; set; }
    }

	public class Parameter
    {
        public string TypeName { get; set; }
        public string Name { get; set; }
        public ParameterIn ParameterIn { get; set; }
        public bool IsRequired { get; set; }

        public Parameter(string typeName, string name, ParameterIn parameterIn, bool isRequired)
        {
            TypeName = typeName;
            Name = name;
            ParameterIn = parameterIn;
            IsRequired = isRequired;
        }
    }

	public enum ParameterIn
    {
        Body,
        Path
    }

	public class Property
    {
        public Property(string typeName, string name)
        {
            TypeName = typeName;
            Name = name;
        }

        public string Name { get; set; }
        public string TypeName { get; set; }
    }

	public class ProxyDefinition
    {
        public ProxyDefinition()
        {
            ClassDefinitions = new List<ClassDefinition>();
            Operations = new List<Operation>();
        }

        public List<ClassDefinition> ClassDefinitions { get; set; }
        public List<Operation> Operations { get; set; }
    }
#>