<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Serialization" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="Newtonsoft.Json.dll" #>
<#@ import namespace="Newtonsoft.Json.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Runtime.InteropServices.ComTypes" #>
<#@ import namespace="System.Xml.Serialization" #>

<#@ include file="$(SolutionDir)\Packages\T4.TemplateFileManager.2.1.2\tools\ttinc\TemplateFilemanager.CS.ttinclude" #>
<#@ output extension=".cs" #>
<# 
	// Recommended editor: Tangible T4 Editor (http://t4-editor.tangible-engineering.com/Download_T4Editor_Plus_ModelingTools.html)
	// after save SimpleSample.tt, the output will be generated in the TestFolder of the project
	var fileProperties = new FileProperties()
	{
		BuildAction = BuildAction.Compile
	};

	var fileManager = TemplateFileManager.Create(this);

	fileManager.IsAutoIndentEnabled = true;
	fileManager.CanOverwriteExistingFile = true;

    var csharpCodeProvider = new CSharpCodeProvider();
    var path = Host.ResolvePath("");
    var swaggerApiProxySettings = Settings.GetSettings(path);
    foreach (var endPoint in swaggerApiProxySettings.EndPoints)
    {
        var httpClient = new HttpClient();
        var result = httpClient.GetStringAsync(endPoint.Url).Result;
        var parser = new SwaggerParser();
        var proxyDefinition = parser.ParseSwaggerDoc(result);
        var proxyName = csharpCodeProvider.CreateValidIdentifier(proxyDefinition.Title.Replace(" ", "")) + "WebProxy";
        
		fileManager.StartNewFile(proxyName + ".cs");

		#>
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

// <#= proxyDefinition.Title #>
// <#= proxyDefinition.Description #>
public class <#= proxyName #>
{
        <# 
		// async operations
        foreach (var operationDef in proxyDefinition.Operations) {
        #>
            // URL: <#= operationDef.Path #>
            // Method: <#= operationDef.Method #>
            public async Task<# if (!string.IsNullOrEmpty(operationDef.ReturnType)) { #><<#= operationDef.ReturnType #>><# } else { #><# } #> <#= operationDef.OperationId #>()
            {
                throw new NotImplementedException();
            }

        <# } 
		#> 

		
		<#

        // classes
        foreach (var classDef in proxyDefinition.ClassDefinitions) {
        #>
            /// note
            public class <#= classDef.Name  #> <# if (!string.IsNullOrEmpty(classDef.Inherits)) { #> : <#= classDef.Inherits  #> <# } #>
            {
            <#
                foreach(var prop in classDef.Properties) {
                #>
                    public	<#= prop.TypeName #> <#= prop.Name #> { get; set; }
                <#
                }
                #>
            }

        <#
        }
		#>
		}
		<#
    }	
	#>

	<#
	fileManager.Process(true);
#>

<#+
    static class Settings
    {
        public static SwaggerApiProxySettings GetSettings(string path)
        {
            using (var settingStream = System.IO.File.OpenRead(Path.Combine(path, "SwaggerApiProxy.tt.settings.xml")))
            {
                var serializer = new XmlSerializer(typeof (SwaggerApiProxySettings));
                return (SwaggerApiProxySettings) serializer.Deserialize(settingStream);
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public partial class SwaggerApiProxySettings
    {
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("EndPoint", IsNullable = false)]
        public SwaggerApiProxySettingsEndPoint[] EndPoints { get; set; }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class SwaggerApiProxySettingsEndPoint
    {
        /// <remarks/>
        public string Url { get; set; }

        /// <remarks/>
        public string Namespace { get; set; }

        /// <remarks/>
        public string Suffix { get; set; }

        /// <remarks/>
        public string BaseProxyClass { get; set; }
    }



    public class SwaggerParser
    {
        public ProxyDefinition ParseSwaggerDoc(string document)
        {
            var jObject = JObject.Parse(document);

            var proxyDefinition = new ProxyDefinition();

            var infoToken = jObject["info"];
            proxyDefinition.Title =  infoToken["title"].ToString();
            var descriptionToken = infoToken["description"];
            proxyDefinition.Description = descriptionToken != null ? descriptionToken.ToString() : null;
            
			ParsePaths(jObject, proxyDefinition);
            ParseDefinitions(jObject, proxyDefinition);

            return proxyDefinition;
        }

        private void ParsePaths(JObject jObject, ProxyDefinition proxyDefinition)
        {
            foreach (var pathToken in jObject["paths"].Cast<JProperty>())
            {
                var path = pathToken.Name;
                foreach (var operationToken in pathToken.First.Cast<JProperty>())
                {
                    var method = operationToken.Name;
                    var operationId = operationToken.First["operationId"].ToString();
                    var descriptionToken = operationToken.First["description"];
                    string description = null;
					if (descriptionToken != null)
                    {
                        description = descriptionToken.ToString();
                    }

                    string returnType;
                    var schema = operationToken.First["responses"]["200"];
                    if (schema != null)
                    {
                        returnType = GetTypeName(schema);
                    }
                    else
                    {
                        returnType = null;
                    }

                    var parameters = new List<Parameter>();
                    var paramTokens = operationToken.First["parameters"];
                    if (paramTokens != null)
                    {
                        foreach (var prop in paramTokens)
                        {
                            var typeName = GetTypeName(prop);
                            var name = prop["name"].ToString();
                            var parameterIn = prop["in"].ToString().Equals("path") ? ParameterIn.Path : ParameterIn.Body;
                            var isRequired = prop["required"].ToObject<bool>();
                            parameters.Add(new Parameter(typeName, name, parameterIn, isRequired));
                        }
                    }

                    proxyDefinition.Operations.Add(new Operation(returnType, method, path, parameters, operationId, description));
                }
            }
        }

        private void ParseDefinitions(JObject jObject, ProxyDefinition proxyDefinition)
        {
            foreach (var definitionToken in jObject["definitions"].Where(i => i.Type == JTokenType.Property).Cast<JProperty>())
            {
                var classDefinition = new ClassDefinition(definitionToken.Name);
                var allOf = definitionToken.First["allOf"];
                if (allOf != null)
                {
                    foreach (var itemToken in allOf)
                    {
                        var refType = itemToken["$ref"] as JValue;
                        if (refType != null)
                        {
                            classDefinition.Inherits = refType.Value.ToString();
                        }

                        var properties = itemToken["properties"];
                        if (properties != null)
                        {
                            foreach (var prop in properties)
                            {
                                var typeName = GetTypeName(prop.First);
                                var name = ((JProperty)prop).Name;
                                classDefinition.Properties.Add(new Property(typeName, name));
                            }
                        }
                    }
                }
                else
                {
                    var properties = definitionToken.Value["properties"];
                    foreach (var prop in properties)
                    {
                        var typeName = GetTypeName(prop.First);
                        var name = ((JProperty)prop).Name;
                        classDefinition.Properties.Add(new Property(typeName, name));
                    }
                }


                proxyDefinition.ClassDefinitions.Add(classDefinition);
            }
        }

        internal string ParseRef(string input)
        {
            return input.StartsWith("#/definitions/") ? input.Substring("#/definitions/".Length) : input;
        }

        internal string GetTypeName(JToken token)
        {
            var refType  =token["$ref"] as JValue;
            if (refType != null)
            {
                return ParseRef(refType.Value.ToString());
            }

            var schema = token["schema"];
            if (schema != null)
            {
                return GetTypeName(schema);
            }

            var type = token["type"] as JValue;
            if (type == null)
                return null;

            if (type.Value.Equals("boolean"))
            {
                return "bool";
            }
            if (type.Value.Equals("string"))
            {
                var format = token["format"] as JValue;
                if (format == null)
                    return "string";

                if (format.Value.Equals("date") || format.Value.Equals("date-time"))
                    return "DateTime";

                if (format.Value.Equals("byte"))
                    return "byte";

                return "string";
            }

            if (type.Value.Equals("integer"))
            {
                var format = token["format"] as JValue;
                if (format != null)
                {
                    if (format.Value.Equals("int32"))
                        return "int";

                    if (format.Value.Equals("int64"))
                        return "long";
                }

                return "int";
            }

            if (type.Value.Equals("number"))
            {
                var format = token["format"] as JValue;
                if (format != null)
                {
                    if (format.Value.Equals("float"))
                        return "float";

                    if (format.Value.Equals("double"))
                        return "long";
                }
            }

            if (type.Value.Equals("array"))
            {
                var jToken = token["items"];
                return string.Format("List<{0}>", GetTypeName(jToken));
            }

            return "";
        }
    }


    public class ClassDefinition
    {
        public ClassDefinition(string name)
        {
            Name = name;
            Properties = new List<Property>();
        }

        public string Name { get; set; }
        public List<Property>  Properties { get; set; }
        public string Inherits { get; set; }
    }

    public class Operation
    {
        public Operation(string returnType, string method, string path, List<Parameter> parameters, string operationId, string description)
        {
            Path = path;
            Method = method;
            Parameters = parameters;
            OperationId = operationId;
            Description = description;
            ReturnType = returnType;
        }

        public string Path { get; set; }
        public string Method { get; set; }
        public List<Parameter> Parameters { get; set; }
        public string OperationId { get; set; }
        public string Description { get; set; }
        public string ReturnType { get; set; }
    }

    public class Parameter
    {
        public string TypeName { get; set; }
        public string Name { get; set; }
        public ParameterIn ParameterIn { get; set; }
        public bool IsRequired { get; set; }

        public Parameter(string typeName, string name, ParameterIn parameterIn, bool isRequired)
        {
            TypeName = typeName;
            Name = name;
            ParameterIn = parameterIn;
            IsRequired = isRequired;
        }
    }

    public enum ParameterIn
    {
        Body,
        Path
    }

    public class Property
    {
        public Property(string typeName, string name)
        {
            TypeName = typeName;
            Name = name;
        }

        public string Name { get; set; }
        public string TypeName { get; set; }
    }

    public class ProxyDefinition
    {
        public ProxyDefinition()
        {
            ClassDefinitions = new List<ClassDefinition>();
            Operations = new List<Operation>();
        }

        public string Title { get; set; }
        public string Version { get; set; }
        public string Description { get; set; }

        public List<ClassDefinition> ClassDefinitions { get; set; }
        public List<Operation> Operations { get; set; }
    }
#>