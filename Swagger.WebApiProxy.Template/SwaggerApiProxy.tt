<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Serialization" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="Newtonsoft.Json.dll" #>
<#@ import namespace="Newtonsoft.Json.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Runtime.InteropServices.ComTypes" #>
<#@ import namespace="System.Xml.Serialization" #>

<#@ include file="$(SolutionDir)\Packages\T4.TemplateFileManager.2.1.2\tools\ttinc\TemplateFilemanager.CS.ttinclude" #>
<#@ output extension=".cs" #>
<# 
    // Recommended editor: Tangible T4 Editor (http://t4-editor.tangible-engineering.com/Download_T4Editor_Plus_ModelingTools.html)
    // after save SimpleSample.tt, the output will be generated in the TestFolder of the project
    var fileProperties = new FileProperties()
    {
        BuildAction = BuildAction.Compile
    };

    // Build output object
    var output = new StringBuilder();

    var fileManager = TemplateFileManager.Create(this);

    fileManager.IsAutoIndentEnabled = true;
    fileManager.CanOverwriteExistingFile = true;

    var csharpCodeProvider = new CSharpCodeProvider();
    var path = Host.ResolvePath("");
    var swaggerApiProxySettings = Settings.GetSettings(path);
    foreach (var endPoint in swaggerApiProxySettings.EndPoints)
    {
        var httpClient = new HttpClient();
        var result = httpClient.GetStringAsync(endPoint.Url).Result;
        var parser = new SwaggerParser();
        var proxyDefinition = parser.ParseSwaggerDoc(result);
        var proxyName = csharpCodeProvider.CreateValidIdentifier(proxyDefinition.Title.Replace(" ", "")) + "WebProxy";
        
        fileManager.StartNewFile(proxyName + ".cs");
        
        // using directives
        output.AppendFormat("using System;").AppendLine();
        output.AppendFormat("using System.Collections.Generic;").AppendLine();
        output.AppendFormat("using System.Threading.Tasks;").AppendLine().AppendLine();

        // class title and description
        output.AppendFormat("// {0}", proxyDefinition.Title).AppendLine();
        output.AppendFormat("// {0}", proxyDefinition.Description).AppendLine();

        // start class defintion
        output.AppendFormat("public class {0}", proxyName).AppendLine();
        output.AppendFormat("{{").AppendLine();

        // Async operations (web methods)
        foreach (var operationDef in proxyDefinition.Operations) {
            string returnType = string.IsNullOrEmpty(operationDef.ReturnType) ? string.Empty : string.Format("<{0}>", operationDef.ReturnType);
            string parameters = string.Join(", ", operationDef.Parameters.Select(x => string.Format("{0} {1}", x.TypeName, x.Name)));

            output.AppendFormat("// URL: {0}", operationDef.Path).AppendLine();
            output.AppendFormat("// Method: {0}", operationDef.Method.ToUpper()).AppendLine();
            output.AppendFormat("public async Task{0} {1}({2})", returnType, operationDef.OperationId, parameters).AppendLine();
            output.AppendFormat("{{").AppendLine();
            output.AppendFormat("throw new NotImplementedException();").AppendLine();
            output.AppendFormat("}}").AppendLine().AppendLine();
        }

        // Model Classes
        foreach (var classDef in proxyDefinition.ClassDefinitions) {
            output.AppendFormat("public class {0} {1}", classDef.Name, string.IsNullOrEmpty(classDef.Inherits) ? string.Empty : string.Format(": {0}", classDef.Inherits)).AppendLine();
            output.AppendFormat("{{").AppendLine();
            foreach(var prop in classDef.Properties) {
                output.AppendFormat("public {0} {1} {{ get; set; }}", prop.TypeName, prop.Name).AppendLine();
            }
            output.AppendFormat("}}").AppendLine().AppendLine();
        }

        // close class def
        output.AppendFormat("}}").AppendLine();
    }
    #>

    <#= 
        output
    #>

    <#
        fileManager.Process(true);
    #>        

    // Class Feature Blocks (Must be last)
    <#+
     public static class Settings
    {
        public static SwaggerApiProxySettings GetSettings(string path)
        {
            using (var settingStream = File.OpenRead(Path.Combine(path, "SwaggerApiProxy.tt.settings.xml")))
            {
                var serializer = new XmlSerializer(typeof(SwaggerApiProxySettings));
                return (SwaggerApiProxySettings)serializer.Deserialize(settingStream);
            }
        }
    }

    /// <remarks/>
    [XmlType(AnonymousType = true)]
    [XmlRoot(Namespace = "", IsNullable = false)]
    public partial class SwaggerApiProxySettings
    {
        /// <remarks/>
        [XmlArrayItem("EndPoint", IsNullable = false)]
        public SwaggerApiProxySettingsEndPoint[] EndPoints { get; set; }
    }

    /// <remarks/>
    [XmlType(AnonymousType = true)]
    public partial class SwaggerApiProxySettingsEndPoint
    {
        /// <remarks/>
        public string Url { get; set; }

        /// <remarks/>
        public string Namespace { get; set; }

        /// <remarks/>
        public string Suffix { get; set; }

        /// <remarks/>
        public string BaseProxyClass { get; set; }
    }



    public class SwaggerParser
    {
        public ProxyDefinition ParseSwaggerDoc(string document)
        {
            var jObject = JObject.Parse(document);

            var proxyDefinition = new ProxyDefinition();

            var infoToken = jObject["info"];
            proxyDefinition.Title = infoToken["title"].ToString();
            var descriptionToken = infoToken["description"];
            proxyDefinition.Description = descriptionToken != null ? descriptionToken.ToString() : null;

            this.ParsePaths(jObject, proxyDefinition);
            this.ParseDefinitions(jObject, proxyDefinition);

            return proxyDefinition;
        }

        private void ParsePaths(JObject jObject, ProxyDefinition proxyDefinition)
        {
            foreach (var pathToken in jObject["paths"].Cast<JProperty>())
            {
                var path = pathToken.Name;
                foreach (var operationToken in pathToken.First.Cast<JProperty>())
                {
                    var method = operationToken.Name;
                    var operationId = operationToken.First["operationId"].ToString();
                    var descriptionToken = operationToken.First["description"];
                    string description = null;
                    if (descriptionToken != null)
                    {
                        description = descriptionToken.ToString();
                    }

                    string returnType;
                    var schema = operationToken.First["responses"]["200"];
                    if (schema != null)
                    {
                        returnType = this.GetTypeName(schema);
                    }
                    else
                    {
                        returnType = null;
                    }

                    var parameters = new List<Parameter>();
                    var paramTokens = operationToken.First["parameters"];
                    if (paramTokens != null)
                    {
                        foreach (var prop in paramTokens)
                        {
                            var typeName = this.GetTypeName(prop);
                            var name = prop["name"].ToString();
                            var parameterIn = prop["in"].ToString().Equals("path") ? ParameterIn.Path : ParameterIn.Body;
                            var isRequired = prop["required"].ToObject<bool>();
                            parameters.Add(new Parameter(typeName, name, parameterIn, isRequired));
                        }
                    }

                    proxyDefinition.Operations.Add(new Operation(returnType, method, path, parameters, operationId, description));
                }
            }
        }

        private void ParseDefinitions(JObject jObject, ProxyDefinition proxyDefinition)
        {
            foreach (var definitionToken in jObject["definitions"].Where(i => i.Type == JTokenType.Property).Cast<JProperty>())
            {
                var classDefinition = new ClassDefinition(definitionToken.Name);
                var allOf = definitionToken.First["allOf"];
                if (allOf != null)
                {
                    foreach (var itemToken in allOf)
                    {
                        var refType = itemToken["$ref"] as JValue;
                        if (refType != null)
                        {
                            classDefinition.Inherits = refType.Value.ToString();
                        }

                        var properties = itemToken["properties"];
                        if (properties != null)
                        {
                            foreach (var prop in properties)
                            {
                                var typeName = this.GetTypeName(prop.First);
                                var name = ((JProperty)prop).Name;
                                classDefinition.Properties.Add(new Property(typeName, name));
                            }
                        }
                    }
                }
                else
                {
                    var properties = definitionToken.Value["properties"];
                    foreach (var prop in properties)
                    {
                        var typeName = this.GetTypeName(prop.First);
                        var name = ((JProperty)prop).Name;
                        classDefinition.Properties.Add(new Property(typeName, name));
                    }
                }


                proxyDefinition.ClassDefinitions.Add(classDefinition);
            }
        }

        internal string ParseRef(string input)
        {
            return input.StartsWith("#/definitions/") ? input.Substring("#/definitions/".Length) : input;
        }

        internal string GetTypeName(JToken token)
        {
            var refType = token["$ref"] as JValue;
            if (refType != null)
            {
                return this.ParseRef(refType.Value.ToString());
            }

            var schema = token["schema"];
            if (schema != null)
            {
                return this.GetTypeName(schema);
            }

            var type = token["type"] as JValue;
            if (type == null)
                return null;

            if (type.Value.Equals("boolean"))
            {
                return "bool";
            }
            if (type.Value.Equals("string"))
            {
                var format = token["format"] as JValue;
                if (format == null)
                    return "string";

                if (format.Value.Equals("date") || format.Value.Equals("date-time"))
                    return "DateTime";

                if (format.Value.Equals("byte"))
                    return "byte";

                return "string";
            }

            if (type.Value.Equals("integer"))
            {
                var format = token["format"] as JValue;
                if (format != null)
                {
                    if (format.Value.Equals("int32"))
                        return "int";

                    if (format.Value.Equals("int64"))
                        return "long";
                }

                return "int";
            }

            if (type.Value.Equals("number"))
            {
                var format = token["format"] as JValue;
                if (format != null)
                {
                    if (format.Value.Equals("float"))
                        return "float";

                    if (format.Value.Equals("double"))
                        return "long";
                }
            }

            if (type.Value.Equals("array"))
            {
                var jToken = token["items"];
                return string.Format("List<{0}>", this.GetTypeName(jToken));
            }

            return "";
        }
    }


    public class ClassDefinition
    {
        public ClassDefinition(string name)
        {
            this.Name = name;
            this.Properties = new List<Property>();
        }

        public string Name { get; set; }
        public List<Property> Properties { get; set; }
        public string Inherits { get; set; }
    }

    public class Operation
    {
        public Operation(string returnType, string method, string path, List<Parameter> parameters, string operationId, string description)
        {
            this.Path = path;
            this.Method = method;
            this.Parameters = parameters;
            this.OperationId = operationId;
            this.Description = description;
            this.ReturnType = returnType;
        }

        public string Path { get; set; }
        public string Method { get; set; }
        public List<Parameter> Parameters { get; set; }
        public string OperationId { get; set; }
        public string Description { get; set; }
        public string ReturnType { get; set; }
    }

    public class Parameter
    {
        public string TypeName { get; set; }
        public string Name { get; set; }
        public ParameterIn ParameterIn { get; set; }
        public bool IsRequired { get; set; }

        public Parameter(string typeName, string name, ParameterIn parameterIn, bool isRequired)
        {
            this.TypeName = typeName;
            this.Name = name;
            this.ParameterIn = parameterIn;
            this.IsRequired = isRequired;
        }
    }

    public enum ParameterIn
    {
        Body,
        Path
    }

    public class Property
    {
        public Property(string typeName, string name)
        {
            this.TypeName = typeName;
            this.Name = name;
        }

        public string Name { get; set; }
        public string TypeName { get; set; }
    }

    public class ProxyDefinition
    {
        public ProxyDefinition()
        {
            this.ClassDefinitions = new List<ClassDefinition>();
            this.Operations = new List<Operation>();
        }

        public string Title { get; set; }
        public string Version { get; set; }
        public string Description { get; set; }

        public List<ClassDefinition> ClassDefinitions { get; set; }
        public List<Operation> Operations { get; set; }
    }
    #>